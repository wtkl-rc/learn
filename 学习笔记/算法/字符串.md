# kmp算法

## 什么是KMP

说到KMP，先说一下KMP这个名字是怎么来的，为什么叫做KMP呢。

因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP

## 有什么用

给一个**文本串**：aabaabaaf，给一个**模式串**：aabaaf，判断模式串是否为文本串的子串。暴力法是其中的一个解决方案，但是时间复杂度为o（m*n），所以用kmp算法。

## 前缀和后缀

abc

前缀就是包含首字母，不包含尾字母的 a，ab

后缀就是包含尾字母，不包含首字母的 c，bc

## next数组的计算

![next](D:\something\github\myCollegeLife\picture\learn\algorithm\string\1.png)

next数组是什么，next数组就是一个**前缀表**，就是最长相等前后缀。



如果你问我为什么要这么写，其实我也不是很懂。可以根据上图最后一个b理解为什么要-1。

我觉得就是，如果b和c不匹配，就判断c前面的a，看看在第一个字母开始是否有和a一样的，因为b和c不匹配，但是也说明了，b和c前面的a是匹配的。所以要判断第一个字母是否和b前面的a一样，所以可以根据c前面的a的next数组的值去判断第一个字母是否存在a。然后再对前后两个a的后面的字符进行判断。如果c前面的a的next数组值为0，就是没有一样的，就直接add0就行了。

```
   public static ArrayList<Integer> build_next(char[] patt){  //patt是字符串数组
        ArrayList<Integer> next= new ArrayList<>(); //定义一个可扩展数组
        int prefix_length=0; //这个是共同前后缀长度
        int i=1;
        while(i<patt.length){
            if(patt[i]==patt[prefix_length]){	//如果字符相等
                prefix_length++;  
                next.add(prefix_length);
                i++;
            }
            else{                         //如果字符不相等
                if(prefix_length==0){    //且前面的
                    next.add(prefix_length);
                    i++;
                }else{
                    prefix_length=next.get(prefix_length-1); //难理解在这个地方，为什么要-1退回去
                }
            }
        }
        return next;
    }
```

## kpm代码实现

![image-20231130152506837](D:\something\github\myCollegeLife\picture\learn\algorithm\string\2.png)

return后面那些细节不要纠结，反正就是这个逻辑，还不是特别懂。

```
    public static int kmp_search(char[] s,int[] patt){
        ArrayList<Integer> next = build_next(s);
        int i=0;    //主串中的指针
        int j=0;    //子串中的指针
        while(i<s.length){
            if(patt[i]==s[i]){  //如果字符相等，指针向前
                j++;
                i++;
            } else if (j>0) {   //如果不是只有一个字符的时候，匹配不到，访问前一个数的next数组
                j=next.get(j-1);
            } else{
                i++;  //如果j=0难就主指针+1
            }
            if(j== patt.length){   //匹配成功
                return i-j;
            }
        }
        return i-j;
    }

```

