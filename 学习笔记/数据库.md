

# 1 绪论

## 1.2数据模型

1.2.1两类数据模型

1.2.2概念模型



## 1.3 数据库系统的结构

1.3.1数据库系统模式的概念



1.3.2数据库系统的三级模式结构

1 模式  模式也称为  **逻辑模式或概念模式**，是数据库中  全体数据的逻辑结构和特征的描述，是  所有用户的公共数据视图。一个数据库只有一个模式，  模式位于三级结构的中间层。 

2 外模式   外模式也称为  **用户模式**，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的  局部数据的逻辑结构和特征的描述，是  数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。  外模式是模式的子集，一个数据库可以有多个外模式。 

3 内模式   内模式也称为  **存储模式**，  一个数据库只有一个内模式，它是数据  物理结构和存储方式的描述，是数据在  数据库内部的表示方式。 



1.3.3数据库的二级映像功能与数据独立性

1 外模式/模式映像

对于  同一个模式可以有任意多个外模式。对于每一个外模式，数据库系统都有一个外模式/模式映射。当模式被改变时，数据库管理员对各个外模式/模式映射做相应的改变，可以使外模式保持不变。这样，依据数据外模式编写的应用程序就不用修改，  保证了数据与程序的逻辑独立性。

2 模式/内模式映像

数据库中只有一个模式和一个内模式，所以 
 模式/内模式的映射是唯一的，它定义了数据库的全局逻辑结构与存储结构之间的对应关系。当数据库的存储结构被改变时，数据库管理员对模式/内模式映射做相应的改变，可以使模式保持不变，应用程序相应地也不做变动。这样， 
 保证了数据与程序的物理独立性。 

## 1.4数据库系统的组成

# 2 关系数据库

## 2.1关系数据结构结构及形式化定义

2.1.1关系

域、笛卡儿积、关系

## 2.2关系操作

2.2.1基本的关系操作



## 2.3关系的完整性

## 2.4关系代数

传统的集合运算和专门的关系运算两类



2.4.1传统的集合运算

并、差、交、笛卡儿积



2.4.2专门的关系运算



1 选择

2 投影





# 3 SQL

3.4

带有any的或all谓词的子查询

```
select * from blog where user_id < any(
    select user_id from blog where article_id=10
);
```

带有exists谓词的子查询

```
select article_title from blog
where exists(
   select user_id from blog where article_id=10
)
```

exists后面为真的话，那么就执行父查询



## 3.7视图

3.7.1定义视图

1 建立视图

```sql
create view zhengshi
as 
select article_title,user_name from user,blog where user_name = "郑十";
```



# 5 数据库完成性

数据库的完整性是指数据的正确性和相容性

数据库管理系统必须能够实现如下功能

1.提供定义完整性约束条件的机制

称为完整性规则，是数据库中的数据必须满足的语义约束条件。

2.提供完整性检查的方法

检查数据否满足完整性约束条件的机制叫完整性检查。

3.进行违约处理

如果违背了完整性约束条件将采取一定动作。

## 5.1实体完整性

5.1.1定义实体完整性

```
create table student{
	sno char(9) primary key;   在列级定义主码
}

 create table student{    
 	sno char(9) not null;  
    primary key (sno);   在表级定义主码
 }
 
  create table student{    
 	sno char(9) not null;  
 	cno char(4) not null;
    primary key (sno,cno);   只能在表级定义主码
 }
```



5.1.2实体完整性检查和违约处理

用primary key定义了主码后，要插入或修改一条数据时，就会自动进行检查

1检查主码值是否唯一，如果不唯一则拒绝

2检查主码的各个属性是否为空，只要有一个为空就拒绝



检主码是否唯一要进行全表扫描，但是很消耗时间，所以建立**B+树索引**

## 5.2参照完整性

5.2.1定义参完整性

foreign key  references

```
  create table sc{    
 	sno char(9) not null,  
 	cno char(4) not null,
    primary key (sno,cno), 在表级定义实体完整性
    foreign key (sno) references student(sno), 在表级定义参照完整性
    foreign key (cno) references course(cno)
 }
```

5.2.2参照完整性检查和违约处理

1 拒绝(no action)执行

不允许该操作执行。该策略一般设置为**默认策略**

2 级联(cascade)操作

删除或修改被参照表的一个元组导致与参照表的不一致时，删除或修改参照表的所有导致不一致的元组

3 设置为空值

被参照表被修改造成不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。当然你还有考虑这个值是否能为空

```
显示说明参照完整性的违约处理示例
create table sc{
	sno char(),
	cno char(),
	primary key (sno,cno),
	foreign key (sno) references student(sno)
		on delete cascade 当删除student表中的元素是，级联删除sc表中相应的元组   
		//on delete no action 拒绝操作
		on update cascade,
}
```

## 5.3用户定义的完整性

5.3.1属性上的约束条件

1 属性上的约束条件定义

not null，unique，check短语定义列值应该满足的条件

```
create table student{
	sno,
	sname, 
	ssex char(2) check(ssex in('男','女'))
}
```

2 属性上约束条件的检查和违约处理

不满足则拒绝操作



5.3.2元组上的约束条件

1 定义元组上约束条件的定义

同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件

```
create table student{
	sno,
	sname, 
	ssex char(2),
	check (ssex='女' or sname not like 'ms.%') 当学生性别是男的时，名字不能以ms.开头
 }
```



如果不满足就拒绝操作

## 5.4完整性约束命名句子

1 完整性约束命名子句

constraint

```
create table student{
	sno numeric(6)
		constraint c1 check (sno between 9000 and 99999) 要求学号在这个区间
}
```

2 修改表中的完整性限制

```
alter table student
	drop constraint c1
alter table student 
	add constraint c2 check (sno between 90 and 90)
```



## 5.6断言

通过声明性断言来指定更具一般性的约束。可以定义涉及多个表或聚集操作的比较复杂的完整性约束。任何对断言中所涉及关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行。

1 创建断言的语句格式

```
限制数据库课程最多60名学生选修
create assertion asse_sc_db_num
	check (60 >= (select count(*)
		from course,sc
			where sc.cno =course.cno and course.cname='数据库')
		);
```

每当sc表中插入一条元组时，都会检查一次断言



2 删除断言

```
drop assertion <断言名>
```



## 5.7触发器

触发器是用户定义在关系表上的一类由事件驱动的特殊过程。类似约束但是比约束更加灵活，可以实施更为复杂的检查和操作，具有更精细和强大的数据控制能力。

5.7.1定义触发器

触发事件 insert，insert or delete

触发器类型 for each row(语句触发器),for each statement(行级触发器)

当对表sc的grade属性进行修改时，若分数增加了10%，则将此次操作记录到另一个表中sc_u（sno，cno，oldgrade，newgrade）

```
create trigger sc_t   //sc_t是触发器的名字
after update of grade on sc  //update of grade on sc是触发事件 
	//after是触发时机，表示对sc的grade修改后再触发下面的规则
referencing 
	oldrow as oldtuple 
	newrow as newtuple
for each row 	//行级触发器，表示每执行一次grade的更新，下面的规则就执行一次
when (newtuple.grade >= 1.1 * oldtuple.grade)  //触发条件，只有该条件为真时才执行
	insert into sc_u (sno,cno,oldgrade,newgrade)	//下面的insert操作
	value(oldtuple.sno,oldtuple.cno,oldtuple.grade,newtuple.grade)
```

5.7.2激活触发器

一个表可能定义了多个before(after)触发器，谁先创建谁先谁先执行

5.7.3删除触发器

drop trigger 触发器名 on 表名



# 6 关系数据理论

## 6.1问题提出

## 6.2规范化

6.2.1函数依赖

函数依赖：在一个表里面，属性X可以映射到属性Y，也就是说知道了X就能确定Y，称X为决定因素。

如果知道了一个学生的学号Sno，那我就能确定他的姓名Sname和年龄Sage。

**完全函数依赖：**如果我想知道某位学生的某一门课的成绩Grade，那我必须得同时知道他的学号Sno和课程号Cno。
但如果我只知道一部分信息，比如他的Sno或者Cno可以吗？答案是不行的！**此时称Y[Grade]完全依赖于X[Sno,Cno]。**

**部分函数依赖：**如果我想知道某位学生的姓名Sname，那我知道他的学号Sno就可以了。也就是说**Y[Sname]只函数依赖于X[Sno,Cno]中的子集x[Sno**]**，此时称Y部分函数依赖于X。**

**传递函数依赖：**如果我知道了一个学生的学号Sno，那我就能知道他所在的系Sdept。(因为理论上一个学生只属于一个系)
如果我知道了某一个系Sdept，那么我就能知道这个系的系主任的姓名Mname。(一个系只有一个正的系主任，别杠，你赢了。)
也就是说，我知道了一个学生的学号Sno，其实我就知道了他所在系的系主任的姓名Mname。但这个过程中，他们是不存在直接函数依赖的，我需要通过系名称Sdept作为一个桥梁去把二者联系起来的。



6.2.3范式

1NF 第一范式列不能再分

6.2.4 2NF

第二范式建立在第一范式的基础上，非主属性完全依赖于码。

6.2.5 3NF

满足第二范式的条件下不存在传递函数依赖。

第一范式：简单说 列不能再分

第二范式：简单说 建立在第一范式基础上，消除部分依赖

第三范式：简单说 建立在第二范式基础上，消除传递依赖。

6.2.6 BCNF

一个满足BCNF的关系模式的条件:

1.所有非主属性对每一个码都是完全函数依赖。

2.所有的主属性对每一个不包含它的码,也是完全函数依赖。

3.没有任何属性完全函数依赖于非码的任何一组属性。



# 7 数据库设计

## 7.1数据库设计概述



## 7.2需求分析

7.2.1 需求分析任务

7.2.2需求分析的方法



7.2.3数据字典

关于数据库中数据的描述，即元数据，而不是数据本身。

数据项：不可再分的数据单位，数据项描述{数据项名、说明、别名、长度、取值等}，对数据项进行描述

数据结构：反映了数据之间的组合关系，一个数据结构可以由若干个数据项组成，或者若干个数据结构{数据结构名、含义说明}

数据流：传输路径

数据存储：数据的来源和去向

处理过程：具体处理逻辑用判定表或判定树来描述

## 7.3概念结构设计

7.3.1概念模型



7.3.2E-R模型

实体、属性、实体之间的联系

1 实体之间的联系

​	两个实体型之间的联系

​	1:1、1:n、m:n

​	两个一上的实体型之间的联系

​	单个实体型内的联系

2 E-R图

实体型用矩形表示、属性用椭圆形表示、联系用菱形表示

## 7.4逻辑结构设计



## 7.5物理结构设计



# 10 数据库恢复技术

## 10.1 事务的基本概念

1 事务

事务是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位

定义事务的语句一般有3条

begin transaction; commit; rollback

2 事务的acid特性

原子性、一致性、隔离性、持续性

原子性 事务中包括的操作要么都做，要么都不做

一致性 一个一致状态到另一个一致状态，当数据只包含成功事务提交的结果是，就说数据库处于一致状态

隔离性 一个事务的执行不能被其他事务干扰

持续性 也叫永久性，事务一旦提交，对数据库中的数据的改变死永久性的

## 10.3故障的种类

1 事务内部的故障

事务内部更多的故障是非预期的，是不能由应用程序自己处理的

2 系统故障

造成系统停止运转的任何事件，使得系统要重新启动

3 介质故障

硬故障，磁盘损坏

4 计算机病毒



## 10.4 恢复的实现技术

10.4.1数据的转存

后备副本，就是直接转到磁盘

静态转存 系统停止运行，然后转存

动态转存 转存期间允许数据库进行存储或修改



动态海量转储、动态增量转储、静态海量转储、静态增量转储

10.4.2登记日志文件

1 日志文件的格式和内容

记录事务对数据库的更新操作的文件

​	登记的内容包括：

​	事务的开始标记、结束标记、所有更新操作

​	日志记录的内容主要包括：

​	事务标识、操作的类型、操作的对象、旧值、新值

2 日志文件的作用

事务故障恢复

动态转储

静态转储也可以建立日志文件

3 登记日志文件

登记日志文件时必须遵循两条原则

登记的次序彦哥按并发事务执行的时间次序

必须先写日志文件，后写数据库

## 10.5恢复策略

10.5.1事务故障的恢复

10.5.2系统故障的恢复

10.5.3介质故障的恢复

## 10.6具有检查点的恢复技术

# 11 并发操作

可以同时多个人同时访问一个数据库，事务可以一个执行完之后再执行下一个，但是效率不高。在单处理机系统中将这些事务轮流交叉运行，称为交叉并发方式。在多处理机系统中，多个处理机运行多个事务，称为同时并发方式。



## 11.1并发控制概述

事务是并发的基本单位，多个事务对数据库的并发操作会造成破坏。

1 丢失数据

两个事务修改同一个数据，b提交的结果破坏了a提交的结果，导致a的修改丢失

2 不可重复读

事务b读取了两次数据，在读取两次的过程中，事务a修改了数据，导致事务b在这两次读取出来的数据不一致

3 读“脏”数据

在事务a执行过程中，事务a对数据进行修改，事务b读取了a修改后的数据，但是a没有完成，回滚了，则事务b读取的就是脏数据

## 11.2封锁

排它锁或写锁

​	事务T对数据对象a加上x锁，则只允许t读取和修改a

共享锁或读锁

​	事务T对a对象加上s锁，则事务t只能读a不能修改a，其他事务只能加s锁



## 11.3封锁协议

一级封锁协议

​	事务T在修改数据R之前必须先加x锁，直到事务结束才释放

二级封锁协议

​	一级基础上，读取数据R要先加s锁，读取完后释放

三级封锁协议

​	一级基础上，读取数据R先加s锁，事务结束后释放



## 11.4活锁和死锁

11.4.1活锁

事务T锁数据R，T2请求，则T2等待释放，T3又请求，T释放后，T3封锁，则T2一直等待

避免活锁的方式就是采用先来先服务的策略



11.4.2死锁

T1锁R1，T2等R1，T1等T2锁死的R2

1 死锁的预防

一次封锁法 直接把这个事务后面所要求的数据全部锁死，会降低系统的并发度

顺序封锁法 预先对数据对象规定一个封锁顺序，所有事物都按照这个封锁顺序实施封锁，但是非常困难

2 死锁的诊断和解除

超时法 会误判死锁

等待图法 把所有等待的情况用图表示出来，检测有没有发生死锁

选择一个处理死锁代价最小的事务，将其撤销，释放次事务持有的所有锁



## 11.5并发调度的可串行性

什么调度是正确的呢，**串行调度**是正确的

11.5.1可串行化调度

当其结果和串行执行这些事务的结果相同时就是可串行化调度



11.5.2冲突可串行化调度

冲突操作 是指对不同的事务对同一个数据的读写操作

不同事务的冲突操作和同一事务的两个操作是不能交换的

一个调度sc在保证冲突操作的次序不变的情况下，通过交换两个事务的不冲突操作的道另外一个事务sc'，如果sc'是串行的，则sc为冲突可串行化调度



## 11.6两段锁协议

数据库系统必须提供一定的手段保证调度是可串行化的，目前普遍采用**两段锁**

第一阶段获得锁，扩展阶段，事务可以申请锁，但不能释放任何锁

第二阶段是释放封锁，收缩阶段，可以释放任何锁，但不能申请任何锁

事务遵守两段封锁协议是可串行化调度的充分条件，而不是必要条件



## 11.7封锁的粒度

封锁对象的大小叫封锁粒度，可以是逻辑单元，也可以是一些物理单元。

封锁粒度越大，则并发度越小，系统开销越小



11.7.1多粒度封锁

在一个系统中国同时支持多种封锁粒度供不同事务选择是比较理想的，称为**多粒度封锁**



**多粒度树**的根结点是整个数据库，**多粒度协议**允许多粒度树中的每个结点被独立地加锁。

对一个结点加锁意味着这个结点的所有后裔结点也被加同样类型的锁。



显示封锁

隐式封锁是该数据对象没有被独立加锁，



11.7.2意向锁



